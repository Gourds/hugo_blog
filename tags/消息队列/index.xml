<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>消息队列 on Gourds</title>
    <link>https://blog.gourds.site/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</link>
    <description>Recent content in 消息队列 on Gourds</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Mon, 25 Apr 2022 15:34:58 +0800</lastBuildDate><atom:link href="https://blog.gourds.site/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>关于Fluentd使用中filter及ES插件的问题记录</title>
      <link>https://blog.gourds.site/post/bigdata/fluentd%E5%A4%9Aoutput%E8%BE%93%E5%87%BA/</link>
      <pubDate>Mon, 25 Apr 2022 15:34:58 +0800</pubDate>
      
      <guid>https://blog.gourds.site/post/bigdata/fluentd%E5%A4%9Aoutput%E8%BE%93%E5%87%BA/</guid>
      <description>消费kafka数据，将数据同时导入ES以及GCS。两种做法，一种是同一Topic及消费组，采用Fluentd的copy类型，将一份数据拷贝为</description>
    </item>
    
    <item>
      <title>关于Kafka分布式消息队列</title>
      <link>https://blog.gourds.site/post/distribution/%E5%85%B3%E4%BA%8Ekafka%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</link>
      <pubDate>Sun, 05 Nov 2017 21:00:00 +0000</pubDate>
      
      <guid>https://blog.gourds.site/post/distribution/%E5%85%B3%E4%BA%8Ekafka%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</guid>
      <description>&lt;p&gt;&lt;strong&gt;背景:&lt;/strong&gt; 直接使用EFK进行日志收集，在大规模高压力的情况下Elasticsearch会存在丢数据的情况，现在考虑使用MQ（Message Queue）进行缓冲，达到不丢数据的目的。由于对于日志收集响应速度并不是十分高，并且对日志的可靠性要求较高，最终选择Kafka来充当消息队列而非官方推荐的redis。这里着重进行kafka介绍，之后会整合EFK+kafka的应用落地记录。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>消息队列介绍及常用MQ对比</title>
      <link>https://blog.gourds.site/post/distribution/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%B8%B8%E7%94%A8mq%E5%AF%B9%E6%AF%94/</link>
      <pubDate>Thu, 05 Nov 2015 21:00:00 +0000</pubDate>
      
      <guid>https://blog.gourds.site/post/distribution/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%B8%B8%E7%94%A8mq%E5%AF%B9%E6%AF%94/</guid>
      <description>&lt;h3 id=&#34;什么是消息队列&#34;&gt;什么是消息队列&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;概述：&lt;/strong&gt; 消息队列（Message Queue）一般大家习惯简称为MQ。主要特点为异步处理,也就是说消息的发送者和接收者不需要同时与消息队列交互。消息会保存在队列中，直到接收者取回它。消息队列和信号相比，能够传递更多的信息。与管道相比，消息队列提供了有格式的数据。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;举一个直观的小例子&lt;/strong&gt;
姐姐小红希望弟弟小明多读书，经常拿好书给小明看。之前的方式是先问小明什么时候有空，然后把书给小明送过去，监督小明把书读完。后来两人都觉得太麻烦，就换了一个方式。
买了一个书架，小红一有好书就放到书架上，小明看到书架上有书就取着读。这里，书架其实就是一个消息队列，小红就是生产者，小明就是消费者。
这样的&lt;strong&gt;好处&lt;/strong&gt;是：
1.小红想给小明书的时候不必问小明什么时候有时间，直接把书放在书架上就行了，小红和小明的时间都更自由
2.小红相信小明的读书自觉和读书能力，不必亲眼观察小明的读书过程，小红只要做一个放书的动作，很节省时间。
3.当明天有另一个爱读书的小伙伴小强加入，小红仍旧只需要把书放到书架上，小明和小强从书架上取书即可
4.书在书架上，小明读的慢就晚点看完，读的快就早点看完，小明的压力会小点。
对应可以总结为：&lt;strong&gt;解耦&lt;/strong&gt;、&lt;strong&gt;提速&lt;/strong&gt;、&lt;strong&gt;广播&lt;/strong&gt;、&lt;strong&gt;削峰&lt;/strong&gt;
相应&lt;strong&gt;缺点&lt;/strong&gt;就是：
1.引入复杂度
2.暂时的不一致性
**PS：**以上内容引自知乎祁达方&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
  </channel>
</rss>
